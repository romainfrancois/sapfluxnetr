#' Metrics summary function
#'
#' Generate daily or above metrics from a site data for the period indicated
#'
#' @section period:
#' \code{period} argument is piped to \code{tibbletime::collapse_index} function.
#' See \code{\link[tibbletime]{collapse_index}} for a detailed explanation but in
#' short:
#' \itemize{
#'   \item{\emph{frequency period} format: "1 day", "7 day", "1 month", "1 year"}
#'   \item{\emph{shorthand} format: "hourly", "daily", "monthly", "yearly"}
#'   \item{\emph{custom} format: a vector of dates to use as custom and more flexible boundaries}
#' }
#'
#' @section .funs:
#' \code{.funs} argument uses the same method as the \code{.funs} argument in the
#' \code{\link[dplyr]{summarise_all}} function of \code{dplyr} package. Basically
#' it accepts a list of function calls generated by funs(), or a character vector
#' of function names, or simply a function. If you want to pass on a custom
#' function you can specify it here.
#'
#' @param sfn_data \code{\link{sfn_data}} or \code{\link{sfn_data_multi}} object
#'   to obtain the metrics from
#'
#' @param period Time period to aggregate data by. See period section for an explanation
#'   about the periods ('daily', 'monthly', 'yearly', ...)
#'
#' @param .funs List of function calls generated by \code{\link[dplyr]{funs}}, or
#'   a character vector of functions means, or simply a function. See .funs section
#'   for more info about supplying custom functions.
#'
#' @param solar Logical indicating if the solarTIMESTAMP must be used instead of
#'   the site local TIMESTAMP. Default to TRUE (use solarTIMESTAMP).
#'
#' @param predawn Logical indicating if metrics for predawn interval must be
#'   also returned.
#'
#' @param pd_start Hour to start the predawn interval
#'
#' @param pd_end Hour to end the predawn interval
#'
#' @param midday Logical indicating if metrics for midday interval must be also
#'   returned.
#'
#' @param md_start Hour to start the midday interval
#'
#' @param md_end Hour to end the midday interval
#'
#' @param nighttime Experimental, not implemented (stats for night time)
#'
#' @param ... optional arguments to pass to methods used
#'   (i.e. tibbletime::collapse_index or summarise funs extra arguments)
#'
#' @family metrics
#'
#' @return For \code{\link{sfn_data}} objects, a tibble with the metrics. For
#'   \code{\link{sfn_data_multi}} objects, a list of tibbles with the metrics
#'   for each site.
#'
#' @examples
#' ## sfn_data
#' data('FOO', pkg = 'sapfluxnetr')
#' sfn_metrics(FOO)
#'
#' ## sfn_data_multi
#' data('sfn_multi', pkg = 'sapfluxnetr')
#' sfn_metrics(FOO)
#'
#' @export

sfn_metrics <- function(
  sfn_data,
  period,
  .funs,
  solar,
  predawn,
  pd_start,
  pd_end,
  midday,
  md_start,
  md_end,
  nighttime,
  ...
) {

  # argument checks
  if (!(class(sfn_data) %in% c('sfn_data', 'sfn_data_multi'))) {
    stop(
      'sfn_metrics only works with sfn_data and sfn_data_multi object classes'
    )
  }

  # we need to check if multi and then repeat the function for each element
  if (is('sfn_data_multi', sfn_data)) {
    sfn_data %>%
      purrr::map(sfn_metrics) -> res_multi

    return(res_multi)
  }

  # if sfn_data then we have to calculate the desired metrics from the data
  sapf_data <- get_sapf(sfn_data, solar = solar)
  env_data <- get_env(sfn_data, solar = solar)

  whole_data <- list(sapf = sapf_data, env = env_data)

  # period summaries: we want to know period means, maximum, minimum, quantiles...
  whole_data %>%
    purrr::map(summarise_by_period, period, .funs, ...) -> period_summary

  # filtering summaries we want to know filtered period (predawn, midday) means,
  # maximum, minimum, quantiles...
  # `summarise_by_period` is a helper function documented in helpers.R

  # predawn
  if (predawn) {
    whole_data %>%
      purrr::map(
        dplyr::filter,
        dplyr::between(lubridate::hour(TIMESTAMP), pd_start, pd_end)
      ) %>%
      purrr::map(summarise_by_period, period, .funs, ...) -> predawn_summary
  } else {
    predawn_summary <- NULL
  }

  # midday
  if (midday) {
    whole_data %>%
      purrr::map(
        dplyr::filter,
        dplyr::between(lubridate::hour(TIMESTAMP), md_start, md_end)
      ) %>%
      purrr::map(summarise_by_period, period, .funs, ...) -> midday_summary
  } else {
    midday_summary <- NULL
  }

  # we create the result object by joining the summaries. If they are null
  # bind_cols ignore them, so no problem, and no need of check if they exist.
  res <- dplyr::bind_cols(period_summary, predawn_summary, midday_summary)
  return(res)
}


####### shorthand functions for sfn_metrics ####################################

#' Complete daily metrics for a site (or multi-site)
#'
#' This function returns a complete summary of the site/s with our exclusive set of metrics developed with love for you
#'
#' @inheritParams sfn_metrics
#'
#' @param probs numeric vector of probabilities for \code{\link[stats]{quantile}}
#'
#' @param na.rm logical; if true, any NA and NaN's are removed in the summarise
#'
#' @param ... optional arguments passed to \code{\link{sfn_metrics}}
#'
#' @family metrics
#'
#' @return For \code{\link{sfn_data}} objects, a tibble with the metrics. For
#'   \code{\link{sfn_data_multi}} objects, a list of tibbles with the metrics
#'   for each site.
#'
#' @export

daily_metrics <- function(
  sfn_data,
  solar = TRUE,
  predawn = TRUE,
  pd_start = 3,
  pd_end = 5,
  midday = TRUE,
  md_start = 11,
  md_end = 13,
  probs = c(0.95, 0.99),
  na.rm = FALSE,
  ...
) {

  # hardcoded values
  period <- 'daily'

  # check if user supplied custom funs (.funs), if not, harcoded values
  dots <- list(...)
  if ('.funs' %in% names(dots)) {
    .funs <- dots[['.funs']]
    dots <- dots[names(dots) != '.funs']
  } else {
    .funs <- dplyr::funs(
      mean(., na.rm = TRUE),
      dplyr::n(),
      data_coverage(.),
      quantile(., na.rm = TRUE),
      max(., na.rm = TRUE),
      min(., na.rm = TRUE),
      max_time(., !!"time := TIMESTAMP"),
      min_time(., !!"time := TIMESTAMP")
    )
    # dots <- c(dots, quo(time := TIMESTAMP))
  }

  # just input all in the sfn_function
  sfn_metrics(
    sfn_data,
    period = period,
    .funs = .funs,
    solar = solar,
    predawn = predawn,
    pd_start = pd_start,
    pd_end = pd_end,
    midday = midday,
    md_start = md_start,
    md_end = md_end,
    probs = probs,
    na.rm = na.rm,
    !!! dots
  )
}

#' Complete monthly metrics for a site (or multi-site)
#'
#' This function returns a complete summary of the site/s
#'
#' @inheritParams daily_metrics
#'
#' @family metrics
#'
#' @return For \code{\link{sfn_data}} objects, a tibble with the metrics. For
#'   \code{\link{sfn_data_multi}} objects, a list of tibbles with the metrics
#'   for each site.
#'
#' @export

monthly_metrics <- function(
  sfn_data,
  solar = TRUE,
  predawn = TRUE,
  pd_start = 3,
  pd_end = 5,
  midday = TRUE,
  md_start = 11,
  md_end = 13,
  probs = c(0.95, 0.99),
  na.rm = FALSE,
  ...
) {

  # hardcoded values
  period <- 'monthly'

  # check if user supplied custom funs (.funs), if not, harcoded values
  dots <- list(...)
  if ('.funs' %in% names(dots)) {
    .funs <- dots[['.funs']]
    dots <- dots[names(dots) != '.funs']
  } else {
    .funs <- dplyr::funs(
      mean(., na.rm = TRUE),
      dplyr::n(),
      data_coverage(.),
      quantile(., na.rm = TRUE),
      max(., na.rm = TRUE),
      min(., na.rm = TRUE),
      max_time(., !!"time := TIMESTAMP"),
      min_time(., !!"time := TIMESTAMP")
    )
    # dots <- c(dots, quo(time := TIMESTAMP))
  }

  # just input all in the sfn_metrics function
  sfn_metrics(
    sfn_data,
    period = period,
    .funs = .funs,
    solar = solar,
    predawn = predawn,
    pd_start = pd_start,
    pd_end = pd_end,
    midday = midday,
    md_start = md_start,
    md_end = md_end,
    probs = probs,
    na.rm = na.rm,
    !!! dots
  )
}




## TODO ahora toca el resto de high level functions para las metricas (daily,
## solo predawn, este tipo de cosas)
