#' Metrics summary function
#'
#' Generate daily or above metrics from a site data for the period indicated
#'
#' @section period:
#' \code{period} argument is piped to \code{tibbletime::collapse_by} function.
#' See \code{\link[tibbletime]{collapse_by}} for a detailed explanation but in
#' short:
#' \itemize{
#'   \item{\emph{frequency period} format: "1 day", "7 day", "1 month", "1 year"}
#'   \item{\emph{shorthand} format: "hourly", "daily", "monthly", "yearly"}
#'   \item{\emph{custom} format: a vector of dates to use as custom and more flexible boundaries}
#' }
#'
#' @section .funs:
#' \code{.funs} argument uses the same method as the \code{.funs} argument in the
#' \code{\link[dplyr]{summarise_all}} function of \code{dplyr} package. Basically
#' it accepts a list of function calls generated by funs(), or a character vector
#' of function names, or simply a function. If you want to pass on a custom
#' function you can specify it here.
#'
#' @param sfn_data \code{\link{sfn_data}} or \code{\link{sfn_data_multi}} object
#'   to obtain the metrics from
#'
#' @param period Time period to aggregate data by. See period section for an explanation
#'   about the periods ('daily', 'monthly', 'yearly', ...)
#'
#' @param .funs List of function calls generated by \code{\link[dplyr]{funs}}, or
#'   a character vector of functions means, or simply a function. See .funs section
#'   for more info about supplying custom functions.
#'
#' @param solar Logical indicating if the solarTIMESTAMP must be used instead of
#'   the site local TIMESTAMP. Default to TRUE (use solarTIMESTAMP).
#'
#' @param predawn Logical indicating if metrics for predawn interval must be
#'   also returned.
#'
#' @param pd_start Hour to start the predawn interval
#'
#' @param pd_end Hour to end the predawn interval
#'
#' @param midday Logical indicating if metrics for midday interval must be also
#'   returned.
#'
#' @param md_start Hour to start the midday interval
#'
#' @param md_end Hour to end the midday interval
#'
#' @param nighttime Experimental, not implemented (stats for night time)
#'
#' @param ... optional arguments to pass to methods used
#'   (i.e. tibbletime::collapse_by or summarise funs extra arguments)
#'
#' @family metrics
#'
#' @return For \code{\link{sfn_data}} objects, a tibble with the metrics. For
#'   \code{\link{sfn_data_multi}} objects, a list of tibbles with the metrics
#'   for each site.
#'
#' @examples
#' ## sfn_data
#' data('FOO', pkg = 'sapfluxnetr')
#' sfn_metrics(FOO)
#'
#' ## sfn_data_multi
#' data('sfn_multi', pkg = 'sapfluxnetr')
#' sfn_metrics(FOO)
#'
#' @export

sfn_metrics <- function(
  sfn_data,
  period,
  .funs,
  solar,
  predawn,
  pd_start,
  pd_end,
  midday,
  md_start,
  md_end,
  nighttime,
  ...
) {

  # argument checks
  if (!(class(sfn_data) %in% c('sfn_data', 'sfn_data_multi'))) {
    stop(
      'sfn_metrics only works with sfn_data and sfn_data_multi object classes'
    )
  }

  # we need to check if multi and then repeat the function for each element
  if (is('sfn_data_multi', sfn_data)) {
    sfn_data %>%
      purrr::map(sfn_metrics) -> res_multi

    return(res_multi)
  }

  # if sfn_data then we have to calculate the desired metrics from the data
  sapf_data <- get_sapf(sfn_data, solar = solar)
  env_data <- get_env(sfn_data, solar = solar)

  whole_data <- list(sapf = sapf_data, env = env_data)

  # period summaries: we want to know period means, maximum, minimum, quantiles...
  whole_data %>%
    purrr::map(period_summaries, period, .funs, ...) -> period_summary

  # filtering summaries we want to know filtered period (predawn, midday) means,
  # maximum, minimum, quantiles...
  # `period_summaries` is a helper function documented in helpers.R
  # predawn
  if (predawn) {
    whole_data %>%
      purrr::map(
        dplyr::filter,
        dplyr::between(lubridate::hour(TIMESTAMP), pd_start, pd_end)
      ) %>%
      purrr::map(period_summaries, period, .funs, ...) -> predawn_summary
  } else {
    predawn_summary <- NULL
  }

  # midday
  if (midday) {
    whole_data %>%
      purrr::map(
        dplyr::filter,
        dplyr::between(lubridate::hour(TIMESTAMP), md_start, md_end)
      ) %>%
      purrr::map(period_summaries, period, .funs, ...) -> midday_summary
  } else {
    midday_summary <- NULL
  }

  # we create the result object by joining the summaries. If they are null
  # bind_cols ignore them, so no problem, and no need of check if they exist.
  res <- dplyr::bind_cols(period_summary, predawn_summary, midday_summary)
  return(res)
}

## TODO ahora toca el resto de high level functions para las metricas (daily,
## solo predawn, este tipo de cosas)
