#' Metrics summary function
#'
#' Generate daily or above metrics from a site data for the period indicated
#'
#' @section period:
#' \code{period} argument is piped to \code{tibbletime::collapse_index} function.
#' See \code{\link[tibbletime]{collapse_index}} for a detailed explanation but in
#' short:
#' \itemize{
#'   \item{\emph{frequency period} format: "1 day", "7 day", "1 month", "1 year"}
#'   \item{\emph{shorthand} format: "hourly", "daily", "monthly", "yearly"}
#'   \item{\emph{custom} format: a vector of dates to use as custom and more flexible boundaries}
#' }
#'
#' @section .funs:
#' \code{.funs} argument uses the same method as the \code{.funs} argument in the
#' \code{\link[dplyr]{summarise_all}} function of \code{dplyr} package. Basically
#' it accepts a list of function calls generated by funs(), or a character vector
#' of function names, or simply a function. If you want to pass on a custom
#' function you can specify it here. See details in \code{\link{summarise_by_period}}
#' for more complex summarising functions declaration.
#'
#' @param sfn_data \code{\link{sfn_data}} or \code{\link{sfn_data_multi}} object
#'   to obtain the metrics from
#'
#' @param period Time period to aggregate data by. See period section for an explanation
#'   about the periods ('daily', 'monthly', 'yearly', ...)
#'
#' @param .funs List of function calls generated by \code{\link[dplyr]{funs}}, or
#'   a character vector of functions means, or simply a function. See .funs section
#'   for more info about supplying custom functions.
#'
#' @param solar Logical indicating if the solarTIMESTAMP must be used instead of
#'   the site local TIMESTAMP. Default to TRUE (use solarTIMESTAMP).
#'
#' @param predawn Logical indicating if metrics for predawn interval must be
#'   also returned.
#'
#' @param pd_start Hour to start the predawn interval
#'
#' @param pd_end Hour to end the predawn interval
#'
#' @param midday Logical indicating if metrics for midday interval must be also
#'   returned.
#'
#' @param md_start Hour to start the midday interval
#'
#' @param md_end Hour to end the midday interval
#'
#' @param nighttime Experimental, not implemented (stats for night time)
#'
#' @param ... optional arguments to pass to methods used
#'   (i.e. tibbletime::collapse_index or summarise funs extra arguments)
#'
#' @family metrics
#'
#' @return For \code{\link{sfn_data}} objects, a list of tbl_time objects 
#'   with the following structure:
#'   \itemize{
#'     \item{$sapf: metrics for the sapflow data
#'           \itemize{
#'             \item{$sapf: general metrics}
#'             \item{$sapf_pd: metrics for predawn interval (if
#'                   \code{predawn = TRUE})}
#'             \item{$sapf_md: metrics for midday interval (if
#'                   \code{midday = TRUE})}
#'           }}
#'     \item{$env: metrics for the environmental data
#'           \itemize{
#'             \item{$env: general metrics}
#'             \item{$env_pd: metrics for predawn interval (if
#'                   \code{predawn = TRUE})}
#'             \item{$env_md: metrics for midday interval (if
#'                   \code{midday = TRUE})}
#'           }}
#'   }
#'   
#'   For \code{\link{sfn_data_multi}} objects, a list of lists of tbl_time objects
#'   with the metrics for each site:
#'   \itemize{
#'     \item{$SITE_CODE
#'       \itemize{
#'         \item{$sapf: metrics for the sapflow data
#'           \itemize{
#'             \item{$sapf: general metrics}
#'             \item{$sapf_pd: metrics for predawn interval (if
#'                   \code{predawn = TRUE})}
#'             \item{$sapf_md: metrics for midday interval (if
#'                   \code{midday = TRUE})}
#'           }}
#'       }
#'       \itemize{
#'         \item{$env: metrics for the environmental data
#'           \itemize{
#'             \item{$env: general metrics}
#'             \item{$env_pd: metrics for predawn interval (if
#'                   \code{predawn = TRUE})}
#'             \item{$env_md: metrics for midday interval (if
#'                   \code{midday = TRUE})}
#'           }}
#'       }
#'     }
#'     \item{$NEXT_SITE_CODE...}
#'   }
#'
#' @examples
#' ## sfn_data
#' data('FOO', pkg = 'sapfluxnetr')
#' FOO_metrics <- sfn_metrics(
#'   FOO,
#'   period = '7 days',
#'   .funs = funs(mean(., na.rm = TRUE), sd(., na.rm = TRUE), n()),
#'   solar = FALSE,
#'   predawn = TRUE,
#'   pd_start = 4,
#'   pd_end = 6,
#'   midday = TRUE,
#'   md_start = 12,
#'   md_end = 14,
#'   side = 'start'
#' )
#' 
#' str(FOO_metrics)
#' FOO_metrics[['sapf']][['sapf_pd']]
#'
#' ## sfn_data_multi
#' data('BAR', pkg = 'sapfluxnetr')
#' data('BAZ', pkg = 'sapfluxnetr')
#' multi_sfn <- sfn_data_multi(FOO, BAR, BAZ)
#' 
#' multi_metrics <- sfn_metrics(
#'   multi_sfn,
#'   period = '7 days',
#'   .funs = funs(mean(., na.rm = TRUE), sd(., na.rm = TRUE), n()),
#'   solar = FALSE,
#'   predawn = TRUE,
#'   pd_start = 4,
#'   pd_end = 6,
#'   midday = TRUE,
#'   md_start = 12,
#'   md_end = 14,
#'   side = 'start'
#' )
#' 
#' str(multi_metrics)
#' 
#' multi_metrics[['FOO']][['sapf']][['sapf_pd']]
#'
#' @export

sfn_metrics <- function(
  sfn_data,
  period,
  .funs,
  solar,
  predawn,
  pd_start,
  pd_end,
  midday,
  md_start,
  md_end,
  # nighttime,
  ...
) {

  # argument checks
  if (!(class(sfn_data) %in% c('sfn_data', 'sfn_data_multi'))) {
    stop(
      'sfn_metrics only works with sfn_data and sfn_data_multi object classes'
    )
  }

  # we need to check if multi and then repeat the function for each element
  if (is(sfn_data, 'sfn_data_multi')) {
    res_multi <- sfn_data %>%
      purrr::map(sfn_metrics,
        period = period,
        .funs = .funs,
        solar = solar,
        predawn = predawn,
        pd_start = pd_start,
        pd_end = pd_end,
        midday = midday,
        md_start = md_start,
        md_end = md_end,
        # nighttime,
        ...
      )

    return(res_multi)
  }

  # if sfn_data then we have to calculate the desired metrics from the data
  sapf_data <- get_sapf(sfn_data, solar = solar)
  env_data <- get_env(sfn_data, solar = solar)

  whole_data <- list(sapf = sapf_data, env = env_data)

  # period summaries: we want to know period means, maximum, minimum, quantiles...
  whole_data %>%
    purrr::map(summarise_by_period, period, .funs, ...) -> period_summary

  # filtering summaries we want to know filtered period (predawn, midday) means,
  # maximum, minimum, quantiles...
  # `summarise_by_period` is a helper function documented in helpers.R

  # predawn
  if (predawn) {
    whole_data %>%
      purrr::map(
        dplyr::filter,
        dplyr::between(lubridate::hour(TIMESTAMP), pd_start, pd_end)
      ) %>%
      purrr::map(summarise_by_period, period, .funs, ...) -> predawn_summary

    names(predawn_summary) <- paste0(names(predawn_summary), '_pd')
    names(predawn_summary[['sapf_pd']]) <- paste0(names(predawn_summary[['sapf_pd']]), '_pd')
    names(predawn_summary[['env_pd']]) <- paste0(names(predawn_summary[['env_pd']]), '_pd')

  } else {
    predawn_summary <- NULL
  }

  # midday
  if (midday) {
    whole_data %>%
      purrr::map(
        dplyr::filter,
        dplyr::between(lubridate::hour(TIMESTAMP), md_start, md_end)
      ) %>%
      purrr::map(summarise_by_period, period, .funs, ...) -> midday_summary

    names(midday_summary) <- paste0(names(midday_summary), '_md')
    names(midday_summary[['sapf_md']]) <- paste0(names(midday_summary[['sapf_md']]), '_md')
    names(midday_summary[['env_md']]) <- paste0(names(midday_summary[['env_md']]), '_md')

  } else {
    midday_summary <- NULL
  }
  
  # we create the result object:
  # res
  #   $sapf
  #     $sapf
  #     $sapf_pd
  #     $spf_md
  #   $env
  #     $env
  #     $env_pd
  #     $env_md
  # this way all is modular and after that they can be combined by bind_cols
  res <- list(
    sapf = list(
      sapf = period_summary[['sapf']],
      sapf_pd = predawn_summary[['sapf_pd']],
      sapf_md = midday_summary[['sapf_md']]
    ),
    env = list(
      env = period_summary[['env']],
      env_pd = predawn_summary[['env_pd']],
      env_md = midday_summary[['env_md']]
    )
  )
  
  return(res)
}


####### shorthand functions for sfn_metrics ####################################

#' Complete daily metrics for a site (or multi-site)
#'
#' This function returns a complete summary of the site/s with our exclusive set of metrics developed with love for you
#'
#' @inheritParams sfn_metrics
#'
#' @param probs numeric vector of probabilities for \code{\link[stats]{quantile}}
#'
#' @param na.rm logical; if true, any NA and NaN's are removed in the summarise
#'
#' @param ... optional arguments passed to \code{\link{sfn_metrics}}
#'
#' @family metrics
#'
#' @return For \code{\link{sfn_data}} objects, a tibble with the metrics. For
#'   \code{\link{sfn_data_multi}} objects, a list of tibbles with the metrics
#'   for each site.
#'
#' @export

daily_metrics <- function(
  sfn_data,
  solar = TRUE,
  predawn = TRUE,
  pd_start = 3,
  pd_end = 5,
  midday = TRUE,
  md_start = 11,
  md_end = 13,
  probs = c(0.95, 0.99),
  na.rm = FALSE,
  ...
) {

  # hardcoded values
  period <- 'daily'

  # check if user supplied custom funs (.funs), if not, harcoded values
  dots <- list(...)
  if ('.funs' %in% names(dots)) {
    .funs <- dots[['.funs']]
    dots <- dots[names(dots) != '.funs']
  } else {
    .funs <- dplyr::funs(
      mean(., na.rm = TRUE),
      dplyr::n(),
      data_coverage(.),
      quantile(., na.rm = TRUE),
      max(., na.rm = TRUE),
      min(., na.rm = TRUE),
      max_time(., !!"time := TIMESTAMP"),
      min_time(., !!"time := TIMESTAMP")
    )
    # dots <- c(dots, quo(time := TIMESTAMP))
  }

  # just input all in the sfn_function
  sfn_metrics(
    sfn_data,
    period = period,
    .funs = .funs,
    solar = solar,
    predawn = predawn,
    pd_start = pd_start,
    pd_end = pd_end,
    midday = midday,
    md_start = md_start,
    md_end = md_end,
    probs = probs,
    na.rm = na.rm,
    !!! dots
  )
}

#' Complete monthly metrics for a site (or multi-site)
#'
#' This function returns a complete summary of the site/s
#'
#' @inheritParams daily_metrics
#'
#' @family metrics
#'
#' @return For \code{\link{sfn_data}} objects, a tibble with the metrics. For
#'   \code{\link{sfn_data_multi}} objects, a list of tibbles with the metrics
#'   for each site.
#'
#' @export

monthly_metrics <- function(
  sfn_data,
  solar = TRUE,
  predawn = TRUE,
  pd_start = 3,
  pd_end = 5,
  midday = TRUE,
  md_start = 11,
  md_end = 13,
  probs = c(0.95, 0.99),
  na.rm = FALSE,
  ...
) {

  # hardcoded values
  period <- 'monthly'

  # check if user supplied custom funs (.funs), if not, harcoded values
  dots <- list(...)
  if ('.funs' %in% names(dots)) {
    .funs <- dots[['.funs']]
    dots <- dots[names(dots) != '.funs']
  } else {
    .funs <- dplyr::funs(
      mean(., na.rm = TRUE),
      dplyr::n(),
      data_coverage(.),
      quantile(., na.rm = TRUE),
      max(., na.rm = TRUE),
      min(., na.rm = TRUE),
      max_time(., !!"time := TIMESTAMP"),
      min_time(., !!"time := TIMESTAMP")
    )
    # dots <- c(dots, quo(time := TIMESTAMP))
  }

  # just input all in the sfn_metrics function
  sfn_metrics(
    sfn_data,
    period = period,
    .funs = .funs,
    solar = solar,
    predawn = predawn,
    pd_start = pd_start,
    pd_end = pd_end,
    midday = midday,
    md_start = md_start,
    md_end = md_end,
    probs = probs,
    na.rm = na.rm,
    !!! dots
  )
}




## TODO ahora toca el resto de high level functions para las metricas (daily,
## solo predawn, este tipo de cosas)
